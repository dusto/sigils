package repository

import (
	"context"

	"github.com/dusto/sigils/internal/model"

	"github.com/google/uuid"
)

/*
All functions here were generated by sqlc but have been customized. SQLc was used to seed query creation
*/

const getClusterByUUID = `-- name: GetClusterByUUID :one
WITH cview AS (
  SELECT c.uuid, c.name, c.endpoint , json_group_array(json_object('configtype', cc.config_type, 'config', cc.config)) configs
FROM clusters c
INNER JOIN cluster_configs cc on c.uuid = cc.cluster_uuid
GROUP BY c.uuid
)
SELECT uuid, name, endpoint, configs FROM cview
WHERE uuid = ?
`

func (q *Queries) GetClusterByUUID(ctx context.Context, argUuid uuid.UUID) (model.Cluster, error) {
	row := q.db.QueryRowContext(ctx, getClusterByUUID, argUuid)
	var i model.Cluster
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Endpoint,
		&i.Configs,
	)
	return i, err
}

const getFullClusterConfigs = `-- name: GetFullClusterConfigs :many
WITH cview AS (
  SELECT c.uuid, c.name, c.endpoint , json_group_array(json_object('configtype', cc.config_type, 'config', cc.config)) configs
FROM clusters c
INNER JOIN cluster_configs cc on c.uuid = cc.cluster_uuid
GROUP BY c.uuid
)
SELECT uuid, name, endpoint, configs FROM cview
`

type GetFullClusterConfigsRow struct {
	Uuid     uuid.UUID
	Name     string
	Endpoint string
	Configs  string
}

func (q *Queries) GetFullClusterConfigs(ctx context.Context) ([]model.Cluster, error) {
	rows, err := q.db.QueryContext(ctx, getFullClusterConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []model.Cluster
	for rows.Next() {
		var i model.Cluster
		var cc model.CConfigType
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Endpoint,
			&cc,
		); err != nil {
			return nil, err
		}
		i.Configs = cc.Configs
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type PatchRow struct {
	Id       int64  `json:"id"`
	NodeType int64  `json:"node_type"`
	Fqdn     string `json:"fqdn"`
	Patch    string `json:"patch"`
}

type ProfileRow struct {
	ID      int64      `json:"id"`
	Name    string     `json:"name"`
	Patches []PatchRow `json:"patches"`
}

const getHosts = `-- name: GetHosts :many
SELECT h.uuid, h.fqdn, h.node_type,
json_group_array(
  (SELECT json_object(
    'id', p.id,
    'name', p.name,
    'patches', (
    SELECT
    json_group_array(json_object(
                'id', pa.id, 
                'node_type', pa.node_type,
                'fqdn', pa.fqdn,
                'patch', pa.patch))
    FROM patches pa
    WHERE ((pa.node_type IN (0,h.node_type) AND pa.host = '') OR pa.fqdn = h.fqdn) AND pa.profile_id = p.id 
    GROUP BY pa.profile_id
    )
  )
  FROM profiles p
  INNER JOIN host_profiles hp ON hp.profile_id = p.id
  WHERE hp.host_uuid = h.uuid
  GROUP BY p.id
)) profiles
FROM hosts h
GROUP BY h.uuid
`

type HostRow struct {
	Uuid     uuid.UUID
	Fqdn     string
	NodeType int64
	Profiles []ProfileRow
}

func (q *Queries) GetHosts(ctx context.Context) ([]HostRow, error) {
	rows, err := q.db.QueryContext(ctx, getHosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []HostRow
	for rows.Next() {
		var i HostRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Fqdn,
			&i.NodeType,
			&i.Profiles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHost = `-- name: GetHost :one
SELECT h.uuid, h.fqdn, h.node_type,
json_group_array(
  (SELECT json_object(
    'id', p.id,
    'name', p.name,
    'patches', (
    SELECT
    json_group_array(json_object(
                'id', pa.id, 
                'node_type', pa.node_type,
                'fqdn', pa.fqdn,
                'patch', pa.patch))
    FROM patches pa
    WHERE ((pa.node_type IN (0,h.node_type) AND pa.host = '') OR pa.fqdn = h.fqdn) AND pa.profile_id = p.id 
    GROUP BY pa.profile_id
    )
  )
  FROM profiles p
  INNER JOIN host_profiles hp ON hp.profile_id = p.id
  WHERE hp.host_uuid = h.uuid
  GROUP BY p.id
)) profiles
FROM hosts h
WHERE h.uuid = ?
GROUP BY h.uuid
`

func (q *Queries) GetHost(ctx context.Context, id uuid.UUID) (HostRow, error) {
	row := q.db.QueryRowContext(ctx, getHost, id)
	var i HostRow
	err := row.Scan(
		&i.Uuid,
		&i.Fqdn,
		&i.NodeType,
		&i.Profiles,
	)
	return i, err
}

const getProfile = `-- name: GetProfile :one
SELECT 
  p.id,
  p.name,
  (
    SELECT
    json_group_array(json_object(
                'id', pa.id, 
                'node_type', pa.node_type,
                'host', pa.host,
                'patch', pa.patch))
    FROM patches pa
    WHERE  pa.profile_id = p.id 
    GROUP BY pa.profile_id
  ) patches
FROM profiles p
WHERE p.id = ?
GROUP BY p.id
`

func (q *Queries) GetProfile(ctx context.Context, id int64) (ProfileRow, error) {
	row := q.db.QueryRowContext(ctx, getProfile, id)
	var i ProfileRow
	err := row.Scan(&i.ID, &i.Name, &i.Patches)
	return i, err
}

const getProfiles = `-- name: GetProfiles :many
SELECT 
  p.id,
  p.name,
  (
    SELECT
    json_group_array(json_object(
                'id', pa.id, 
                'node_type', pa.node_type,
                'host', pa.host,
                'patch', pa.patch))
    FROM patches pa
    WHERE  pa.profile_id = p.id 
    GROUP BY pa.profile_id
  ) patches
FROM profiles p
GROUP BY p.id
`

func (q *Queries) GetProfiles(ctx context.Context) ([]ProfileRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProfileRow
	for rows.Next() {
		var i ProfileRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Patches); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
