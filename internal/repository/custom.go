package repository

import (
	"context"

	"github.com/dusto/sigils/internal/model"

	"github.com/google/uuid"
)

/*
All functions here were generated by sqlc but have been customized. SQLc was used to seed query creation
*/

const getClusterByUUID = `-- name: GetClusterByUUID :one
WITH cview AS (
  SELECT c.uuid, c.name, c.endpoint , json_group_array(json_object('configtype', cc.config_type, 'config', cc.config)) configs
FROM clusters c
INNER JOIN cluster_configs cc on c.uuid = cc.cluster_uuid
GROUP BY c.uuid
)
SELECT uuid, name, endpoint, configs FROM cview
WHERE uuid = ?
`

func (q *Queries) GetClusterByUUID(ctx context.Context, argUuid uuid.UUID) (model.Cluster, error) {
	row := q.db.QueryRowContext(ctx, getClusterByUUID, argUuid)
	var i model.Cluster
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Endpoint,
		&i.Configs,
	)
	return i, err
}

const getFullClusterConfigs = `-- name: GetFullClusterConfigs :many
WITH cview AS (
  SELECT c.uuid, c.name, c.endpoint , json_group_array(json_object('configtype', cc.config_type, 'config', cc.config)) configs
FROM clusters c
INNER JOIN cluster_configs cc on c.uuid = cc.cluster_uuid
GROUP BY c.uuid
)
SELECT uuid, name, endpoint, configs FROM cview
`

func (q *Queries) GetFullClusterConfigs(ctx context.Context) ([]model.Cluster, error) {
	rows, err := q.db.QueryContext(ctx, getFullClusterConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []model.Cluster
	for rows.Next() {
		var i model.Cluster
		var cc model.CConfigType
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Endpoint,
			&cc,
		); err != nil {
			return nil, err
		}
		i.Configs = cc.Configs
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHosts = `-- name: GetHosts :many
SELECT h.uuid, h.mac, h.fqdn, h.nodetype, ifnull(c.name, ''), json_group_array(json_object('id', p.id, 'name', p.name, 'patches', json(ppa.patches))) profiles
FROM hosts h
JOIN host_profiles hp ON hp.host_uuid = h.uuid
JOIN profiles p ON p.id = hp.profile_id
JOIN (SELECT fqdn, nodetype, profile_id, json_group_array(json_object('id', pa.id, 'fqdn', pa.fqdn, 'nodetype', pa.nodetype, 'patch', pa.patch)) patches FROM patches pa GROUP BY profile_id ) ppa ON ((ppa.nodetype IN ('all',h.nodetype) AND ppa.fqdn = '') OR ppa.fqdn = h.fqdn) AND ppa.profile_id = p.id 
FULL JOIN host_clusters hc on hc.host_uuid = h.uuid
FULL JOIN clusters c on c.uuid = hc.cluster_uuid
GROUP BY h.uuid
`

func (q *Queries) GetHosts(ctx context.Context) ([]model.Host, error) {
	rows, err := q.db.QueryContext(ctx, getHosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []model.Host
	for rows.Next() {
		var i model.Host
		var p model.CProfileType
		if err := rows.Scan(
			&i.Uuid,
			&i.Mac,
			&i.Fqdn,
			&i.NodeType,
			&i.ClusterName,
			&p,
		); err != nil {
			return nil, err
		}
		if p.Profiles != nil {
			i.Profiles = p.Profiles

		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHost = `-- name: GetHost :one
SELECT h.uuid, h.mac, h.fqdn, h.nodetype, ifnull(c.name, ''), json_group_array(json_object('id', p.id, 'name', p.name, 'patches', json(ppa.patches))) profiles
FROM hosts h
JOIN host_profiles hp ON hp.host_uuid = h.uuid
JOIN profiles p ON p.id = hp.profile_id
JOIN (SELECT fqdn, nodetype, profile_id, json_group_array(json_object('id', pa.id, 'fqdn', pa.fqdn, 'nodetype', pa.nodetype, 'patch', pa.patch)) patches FROM patches pa GROUP BY profile_id ) ppa ON ((ppa.nodetype IN ('all',h.nodetype) AND ppa.fqdn = '') OR ppa.fqdn = h.fqdn) AND ppa.profile_id = p.id 
FULL JOIN host_clusters hc on hc.host_uuid = h.uuid
FULL JOIN clusters c on c.uuid = hc.cluster_uuid
WHERE h.uuid = ?
GROUP BY h.uuid
`

func (q *Queries) GetHost(ctx context.Context, id uuid.UUID) (model.Host, error) {
	row := q.db.QueryRowContext(ctx, getHost, id)
	var i model.Host
	var p model.CProfileType
	err := row.Scan(
		&i.Uuid,
		&i.Mac,
		&i.Fqdn,
		&i.NodeType,
		&i.ClusterName,
		&p,
	)
	i.Profiles = p.Profiles
	return i, err
}

const getMachineConfig = `-- name: GetMachineConfig :one
SELECT h.uuid, h.mac, h.fqdn, h.nodetype, c.name,
  json_group_array(json_object('id', p.id, 'name', p.name, 'patches', json(ppa.patches))) profiles,
  cc.config machineconfig
FROM hosts h
JOIN host_profiles hp ON hp.host_uuid = h.uuid
JOIN profiles p ON p.id = hp.profile_id
JOIN (SELECT fqdn, nodetype, profile_id, json_group_array(json_object('id', pa.id, 'fqdn', pa.fqdn, 'nodetype', pa.nodetype, 'patch', pa.patch)) patches FROM patches pa GROUP BY profile_id ) ppa ON ((ppa.nodetype IN ('all',h.nodetype) AND ppa.fqdn = '') OR ppa.fqdn = h.fqdn) AND ppa.profile_id = p.id 
INNER JOIN host_clusters hc on hc.host_uuid = h.uuid
INNER JOIN clusters c on c.uuid = hc.cluster_uuid
INNER JOIN cluster_configs cc on cc.cluster_uuid = c.uuid and cc.config_type = h.nodetype
WHERE h.uuid = ? OR h.mac = ? OR h.fqdn = ?
GROUP BY h.uuid
`

func (q *Queries) GetMachineConfig(ctx context.Context, id uuid.UUID, mac, fqdn string) (model.MachineConfig, error) {
	row := q.db.QueryRowContext(ctx, getMachineConfig, id, mac, fqdn)
	var i model.MachineConfig
	var p model.CProfileType
	err := row.Scan(
		&i.Uuid,
		&i.Mac,
		&i.Fqdn,
		&i.NodeType,
		&i.ClusterName,
		&p,
		&i.MachineConfig,
	)
	i.Profiles = p.Profiles
	return i, err
}

const getProfile = `-- name: GetProfile :one
SELECT 
  p.id,
  p.name,
  (
    SELECT
    json_group_array(json_object(
                'id', pa.id, 
                'nodetype', pa.nodetype,
                'fqdn', pa.fqdn,
                'patch', pa.patch))
    FROM patches pa
    WHERE  pa.profile_id = p.id 
    GROUP BY pa.profile_id
  ) patches
FROM profiles p
WHERE p.id = ?
GROUP BY p.id
`

func (q *Queries) GetProfile(ctx context.Context, id int64) (model.Profile, error) {
	row := q.db.QueryRowContext(ctx, getProfile, id)
	var i model.Profile
	var p model.CPatchType
	err := row.Scan(&i.Id, &i.Name, &p)
	i.Patches = p.Patches
	return i, err
}

const getProfiles = `-- name: GetProfiles :many
SELECT 
  p.id,
  p.name,
  (
    SELECT
    json_group_array(json_object(
                'id', pa.id, 
                'nodetype', pa.nodetype,
                'fqdn', pa.fqdn,
                'patch', pa.patch))
    FROM patches pa
    WHERE  pa.profile_id = p.id 
    GROUP BY pa.profile_id
  ) patches
FROM profiles p
GROUP BY p.id
`

func (q *Queries) GetProfiles(ctx context.Context) ([]model.Profile, error) {
	rows, err := q.db.QueryContext(ctx, getProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []model.Profile
	for rows.Next() {
		var i model.Profile
		var p model.CPatchType
		if err := rows.Scan(&i.Id, &i.Name, &p); err != nil {
			return nil, err
		}
		i.Patches = p.Patches
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
